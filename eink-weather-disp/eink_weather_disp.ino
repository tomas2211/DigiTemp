#include "Arduino.h"
#include "epd2in9.h"
#include "epdpaint.h"
#include "DialogInput_bold_16.h"

#include <SPI.h>
#include "RFM69.h"
#include "RFM69_ATC.h"

// RFM69 defines
#define NODEID        1    // keep UNIQUE for each node on same network
#define NETWORKID     100  // keep IDENTICAL on all nodes that talk to each other
#define GATEWAYID     0    // "central" node
#define FREQUENCY   RF69_433MHZ
#define ENCRYPTKEY    "sampleEncryptKey"


RFM69_ATC radio(6, 2, false);
byte ackCount = 0;
uint32_t packetCount = 0;
char buff[50];

const uint8_t moon[] PROGMEM = {
        0xff, 0xa0, 0x10, 0xff, 0xff, 0xa0, 0x20, 0xff, 0xff, 0xa0, 0x20, 0xff, 0xff, 0xa0, 0x20, 0xff, 0xff, 0x60, 0xb0, 0xff, 0xff, 0x10, 0xb0, 0xff, 0xff, 0x20, 0x90, 0xff, 0xff, 0x50, 0x50, 0xff, 0xff, 0x70, 0x50, 0xff, 0xff, 0x60, 0x70, 0xff, 0xff, 0x50, 0x20, 0x10, 0x20, 0xff, 0xff, 0x50, 0x10, 0x20, 0x20, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x20, 0x10, 0xff, 0xff, 0xb0, 0x20, 0xff, 0xff, 0xa0, 0x20, 0xff, 0xff, 0xa0, 0x20, 0xff, 0xff, 0x90, 0x30, 0xf8, 0x03, 0x0f, 0xf7, 0x0b, 0x0f, 0x10, 0x60, 0xff, 0x70, 0xb0, 0xf0, 0x70, 0xff, 0x80, 0x90, 0xe0, 0x90, 0xff, 0xc0, 0x20, 0xf1, 0x04, 0x01, 0x02, 0x0f, 0xfd, 0x02, 0x0e, 0x05, 0x02, 0x02, 0x0f, 0xfd, 0x02, 0x0d, 0x04, 0x04, 0x02, 0x0f, 0xfd, 0x01, 0x0d, 0x04, 0x05, 0x02, 0x0f, 0xff, 0xe0, 0x30, 0x60, 0x20, 0xff, 0xfd, 0x03, 0x06, 0x02, 0x0f, 0x30, 0x10, 0xff, 0x70, 0x30, 0x70, 0x20, 0xf2, 0x02, 0x0f, 0xf6, 0x03, 0x08, 0x02, 0x0f, 0x20, 0x20, 0xff, 0x60, 0x20, 0x90, 0x20, 0xf2, 0x02, 0x0f, 0xf5, 0x03, 0x09, 0x02, 0x0e, 0x09, 0x0f, 0xf1, 0x02, 0x0b, 0x02, 0x0c, 0x0b, 0x0f, 0xe0, 0x20, 0xc0, 0x20, 0xc0, 0xb0, 0xfe, 0x02, 0x0c, 0x02, 0x0f, 0x10, 0x30, 0xff, 0x20, 0x30, 0xc0, 0x20, 0xf1, 0x02, 0x0f, 0xf3, 0x02, 0x0d, 0x03, 0x0f, 0x02, 0x0f, 0xf3, 0x02, 0x0e, 0x02, 0x0f, 0x02, 0x0f, 0xf2, 0x03, 0x0e, 0x02, 0x0f, 0x10, 0x10, 0xff, 0x20, 0x20, 0xf0, 0x30, 0xff, 0xf5, 0x02, 0x0f, 0x10, 0x20, 0xff, 0xf5, 0x02, 0x0f, 0x10, 0x30, 0xff, 0xa0, 0x10, 0x60, 0x20, 0xf2, 0x02, 0x0f, 0xf9, 0x03, 0x05, 0x02, 0x0f, 0x20, 0x30, 0xff, 0x80, 0x30, 0x50, 0x20, 0xf3, 0x03, 0x0f, 0xf4, 0x01, 0x00, 0x30, 0x10, 0x10, 0x10, 0x20, 0xf4, 0x03, 0x0f, 0xf2, 0x0b, 0x01, 0x02, 0x0f, 0x50, 0x30, 0xff, 0x10, 0xb0, 0x10, 0x20, 0xf5, 0x04, 0x0f, 0xf2, 0x07, 0x03, 0x02, 0x0f, 0x60, 0x40, 0xff, 0x20, 0x50, 0x40, 0x20, 0xf7, 0x04, 0x0f, 0xf1, 0x06, 0x03, 0x02, 0x0f, 0x80, 0x50, 0xfd, 0x03, 0x00, 0x20, 0x40, 0x20, 0xf9, 0x04, 0x0f, 0xc0, 0x20, 0x10, 0x20, 0x40, 0x20, 0xfa, 0x06, 0x0f, 0x90, 0x10, 0x30, 0x10, 0x40, 0x20, 0xfc, 0x07, 0x0b, 0x02, 0x0f, 0x50, 0x20, 0xfd, 0x0f, 0x50, 0xf5, 0x02, 0x0f, 0xf0, 0xf3, 0x0f, 0x50, 0x30, 0xff, 0x30, 0xe0, 0xf6, 0x02, 0x0f, 0xfe, 0x02, 0x0f, 0x70, 0x30, 0xff, 0xc0, 0x20, 0xf9, 0x03, 0x0f, 0xfa, 0x03, 0x0f, 0xa0, 0x20, 0xff, 0x90, 0x30, 0xfb, 0x03, 0x0f, 0xf8, 0x03, 0x0f, 0xc0, 0x30, 0xff, 0x60, 0x30, 0xfe, 0x03, 0x0f, 0xf4, 0x03, 0x0f, 0xf1, 0x04, 0x0f, 0xf0, 0x40, 0xff, 0x30, 0x40, 0xfd, 0x04, 0x0f, 0xf5, 0x05, 0x0f, 0x90, 0x50, 0xff, 0x80, 0x40, 0xf6, 0x05, 0x0f, 0xfb, 0x06, 0x0f, 0x10, 0x60, 0xff, 0xe0, 0x80, 0x80, 0x80, 0xff, 0xf3, 0x0f, 0x70, 0xff, 0xf7, 0x0f, 0x30, 0xff, 0xfd, 0x0a, 0x0f, 0xff
};


// Eink defines
unsigned char image[1024]; // image buffer
Paint paint(image, 0, 0);    // width should be the multiple of 8
Epd epd;
unsigned long time_start_ms;
unsigned long time_now_s;
bool redraw;


void setup() {
    // put your setup code here, to run once:
    Serial.begin(115200);
    Serial.println("START - E-ink module");

    Serial.println("INIT display");
    if (epd.Init(lut_full_update) != 0) {
        Serial.println("e-Paper init failed");
        return;
    }

    /**
     *  there are 2 memory areas embedded in the e-paper display
     *  and once the display is refreshed, the memory area will be auto-toggled,
     *  i.e. the next action of SetFrameMemory will set the other memory area
     *  therefore you have to clear the frame memory twice.
     */
    epd.ClearFrameMemory(0xFF);   // bit set = white, bit reset = black
    epd.DisplayFrame();
    epd.ClearFrameMemory(0xFF);   // bit set = white, bit reset = black
    epd.DisplayFrame();

    if (epd.Init(lut_partial_update) != 0) {
        Serial.println("e-Paper init failed");
        return;
    }
    paint.SetWidth(74);
    paint.SetHeight(74);
    paint.SetRotate(ROTATE_90);
    paint.Clear(1);
    redraw = true;


    Serial.println("INIT radio");
    radio.initialize(FREQUENCY, NODEID, NETWORKID);
    radio.encrypt(ENCRYPTKEY);

    sprintf(buff, "\nListening at %d Mhz...", FREQUENCY == RF69_433MHZ ? 433 : FREQUENCY == RF69_868MHZ ? 868 : 915);
    Serial.println(buff);
    Serial.println("RFM69_ATC Enabled (Auto Transmission Control)");

    time_start_ms = millis();
}

void loop() {
    //process any serial input
    if (Serial.available() > 0)
    {
        char input = Serial.read();
        if (input == 'r') //d=dump all register values
            radio.readAllRegs();
        if (input == 'E') //E=enable encryption
            radio.encrypt(ENCRYPTKEY);
        if (input == 'e') //e=disable encryption
            radio.encrypt(null);
        if (input == 't')
        {
            byte temperature =  radio.readTemperature(-1); // -1 = user cal factor, adjust for correct ambient
            byte fTemp = 1.8 * temperature + 32; // 9/5=1.8
            Serial.print( "Radio Temp is ");
            Serial.print(temperature);
            Serial.print("C, ");
            Serial.print(fTemp); //converting to F loses some resolution, obvious when C is on edge between 2 values (ie 26C=78F, 27C=80F)
            Serial.println('F');
        }
    }

    if (radio.receiveDone()) {
        Serial.print("#[");
        Serial.print(++packetCount);
        Serial.print(']');
        Serial.print('[');
        Serial.print(radio.SENDERID, DEC);
        Serial.print("] ");

        for (byte i = 0; i < radio.DATALEN; i++)
            Serial.print((char) radio.DATA[i]);
        Serial.print("   [RX_RSSI:");
        Serial.print(radio.RSSI);
        Serial.print("]");

        if (radio.ACKRequested()) {
            byte theNodeID = radio.SENDERID;
            radio.sendACK();
            Serial.print(" - ACK sent.");

            // When a node requests an ACK, respond to the ACK
            // and also send a packet requesting an ACK (every 3rd one only)
            // This way both TX/RX NODE functions are tested on 1 end at the GATEWAY
            if (ackCount++ % 3 == 0) {
                Serial.print(" Pinging node ");
                Serial.print(theNodeID);
                Serial.print(" - ACK...");
                delay(3); //need this when sending right after reception .. ?
                if (radio.sendWithRetry(theNodeID, "ACK TEST", 8, 0))  // 0 = only 1 attempt, no retries
                    Serial.print("ok!");
                else Serial.print("nothing");
            }
        }
        Serial.println();
    }



    if(redraw) {
//    paint.setTextColor(1);
//    paint.setFont(&DialogInput_bold_16);
//    paint.setCursor(0, 0);
//    paint.DrawStringAt(0, 4, time_string, &Font24, COLORED);
//    paint.print(millis());
//    paint.setCursor(0, 30);
//    paint.print("  Hello world!");
//    paint.DrawCharAt(0,4,'a', &Open_Sans_Regular_10, COLORED);
//    paint.DrawCharAt(12,4,'h', &Open_Sans_Regular_10, COLORED);
//    paint.PutBMPAt(0,0,50,50, icon, false);
        paint.PutBMP4bitCompAt(0, 0, 74, 74, moon, false);
        epd.SetFrameMemory(paint.GetImage(), 128 - 74, 0, paint.GetWidth(), paint.GetHeight());
        paint.PutBMP4bitCompAt(0, 0, 74, 74, moon, false);
        epd.SetFrameMemory(paint.GetImage(), 128 - 74, 74, paint.GetWidth(), paint.GetHeight());
        epd.SetFrameMemory(paint.GetImage(), 128 - 74, 148, paint.GetWidth(), paint.GetHeight());
        paint.PutBMP4bitCompAt(0, 0, 74, 74, moon, false);
        epd.SetFrameMemory(paint.GetImage(), 128 - 74, 222, paint.GetWidth(), paint.GetHeight());
        epd.DisplayFrame();
        redraw = false;
    }


}